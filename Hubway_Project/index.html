<!DOCTYPE html>
<meta charset="utf-8">
<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: black	;
  stroke-width: 0px;
}

</style>
<svg width="800" height="500"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-queue.v3.min.js"></script>
<script>
var links_data = []; // create an empty array
var queue = d3.queue()
.defer(d3.json,"viz3_stations.json")
.defer(d3.json, "viz3_links.json")
//.defer(d3.csv, "station_prac.csv")
.await(draw)
/*
function parseStations(d) {
    return {
        name : +d.name,
        id: d.id,
        type: +d.type
    };
}
*/

function draw(err,nodes_data,links_data) {
    console.log(links_data)
    console.log(nodes_data)
    data = links_data.filter(function(d,i){return i < 100});
    var links = links_data;
    console.log(links)
    console.log(nodes_data)
//    console.log(nodes_data)
//    links.forEach(function(d){
//        for (var i=0;i<nodes_data.length;i++){
//            if (d['start station name'] === nodes_data[i].name){
//
//                d.nStart = nodes_data[i].id;
//            }
//            
//            if (d['end station name'] === nodes_data[i].name){
//                d.nEnd = nodes_data[i].id
//            }
//        }
//    })
//    console.log(links)
    //any other functions that depend on data
    
//    var nodes = {};
//    console.log(data)  
//var data = d3.nest()
//  .key(function(d) { return d.nStart+"***"+d.nEnd;})
//  .entries(links)
/*
data.forEach(function(d){
   var stations = d.key.split("***");
    
    if (stations[0]!=="undefined" && stations[1]!=="undefined"){
        links_data.push({
    "source":   +stations[0],
    "target": +stations[1],
    "type": +st
})
*/
//    }
//    ;
//    console.log(data)
//    links_data = links_data.filter(function(d){return d.source !== NaN && d.target !== NaN})
    
   // console.log(links);
    
//nodes_data = nodes_data.filter(function(d){
//    var match = false;
//    
//    for (var i=0; i<links_data.length;i++){
//    
//        var station_start = links_data[i].source;
//        var station_end = links_data[i].target;
//        
//       
//        if (d.id === station_start || d.id === station_end){
//            console.log("yes")
//            match = true
//        }
//}
//    return match === true
//})
//    
    
//    console.log(links_data)


//data.forEach(function(d){
//    var stations = d.key.split("_");
//    nodes_data.push({
//    "id":   stations[1],
//    "string": 'hello'
//});
//  //  new_array.push(stations[0],stations[1],d.values.length);
//})
    

//console.log(links_data)
//    var try_nodes = nodes_data;
//console.log(try_nodes)
//create somewhere to put the force directed graph

var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");
    
var radius = 15; 

    /*
var nodes_data =  [
    {"name": "Lillian", "sex": "F"},
    {"name": "Gordon", "sex": "M"},
    {"name": "Sylvester", "sex": "M"},
    {"name": "Mary", "sex": "F"},
    {"name": "Helen", "sex": "F"},
    {"name": "Jamie", "sex": "M"},
    {"name": "Jessie", "sex": "F"},
    {"name": "Ashton", "sex": "M"},
    {"name": "Duncan", "sex": "M"},
    {"name": "Evette", "sex": "F"},
    {"name": "Mauer", "sex": "M"},
    {"name": "Fray", "sex": "F"},
    {"name": "Duke", "sex": "M"},
    {"name": "Baron", "sex": "M"},
    {"name": "Infante", "sex": "M"},
    {"name": "Percy", "sex": "M"},
    {"name": "Cynthia", "sex": "F"},
    {"name": "Feyton", "sex": "M"},
    {"name": "Lesley", "sex": "F"},
    {"name": "Yvette", "sex": "F"},
    {"name": "Maria", "sex": "F"},
    {"name": "Lexy", "sex": "F"},
    {"name": "Peter", "sex": "M"},
    {"name": "Ashley", "sex": "F"},
    {"name": "Finkler", "sex": "M"},
    {"name": "Damo", "sex": "M"},
    {"name": "Imogen", "sex": "F"}
    ]
  */  

//Sample links data 
//type: A for Ally, E for Enemy
    /*
var links_data = [
	{"source": "Sylvester", "target": "Gordon", "type":"A" },
    {"source": "Sylvester", "target": "Lillian", "type":"A" },
    {"source": "Sylvester", "target": "Mary", "type":"A"},
    {"source": "Sylvester", "target": "Jamie", "type":"A"},
    {"source": "Sylvester", "target": "Jessie", "type":"A"},
    {"source": "Sylvester", "target": "Helen", "type":"A"},
    {"source": "Helen", "target": "Gordon", "type":"A"},
    {"source": "Mary", "target": "Lillian", "type":"A"},
    {"source": "Ashton", "target": "Mary", "type":"A"},
    {"source": "Duncan", "target": "Jamie", "type":"A"},
    {"source": "Gordon", "target": "Jessie", "type":"A"},
    {"source": "Sylvester", "target": "Fray", "type":"E"},
    {"source": "Fray", "target": "Mauer", "type":"A"},
    {"source": "Fray", "target": "Cynthia", "type":"A"},
    {"source": "Fray", "target": "Percy", "type":"A"},
    {"source": "Percy", "target": "Cynthia", "type":"A"},
    {"source": "Infante", "target": "Duke", "type":"A"},
    {"source": "Duke", "target": "Gordon", "type":"A"},
    {"source": "Duke", "target": "Sylvester", "type":"A"},
    {"source": "Baron", "target": "Duke", "type":"A"},
    {"source": "Baron", "target": "Sylvester", "type":"E"},
    {"source": "Evette", "target": "Sylvester", "type":"E"},
    {"source": "Cynthia", "target": "Sylvester", "type":"E"},
    {"source": "Cynthia", "target": "Jamie", "type":"E"},
    {"source": "Mauer", "target": "Jessie", "type":"E"},
    {"source": "Duke", "target": "Lexy", "type":"A"},
    {"source": "Feyton", "target": "Lexy", "type":"A"},
    {"source": "Maria", "target": "Feyton", "type":"A"},
    {"source": "Baron", "target": "Yvette", "type":"E"},
    {"source": "Evette", "target": "Maria", "type":"E"},
    {"source": "Cynthia", "target": "Yvette", "type":"E"},
    {"source": "Maria", "target": "Jamie", "type":"E"},
    {"source": "Maria", "target": "Lesley", "type":"E"},
    {"source": "Ashley", "target": "Damo", "type":"A"},
    {"source": "Damo", "target": "Lexy", "type":"A"},
    {"source": "Maria", "target": "Feyton", "type":"A"},
    {"source": "Finkler", "target": "Ashley", "type":"E"},
    {"source": "Sylvester", "target": "Maria", "type":"E"},
    {"source": "Peter", "target": "Finkler", "type":"E"},
    {"source": "Ashley", "target": "Gordon", "type":"E"},
    {"source": "Maria", "target": "Imogen", "type":"E"}
    
]
*/

//set up the simulation and add forces
    
var simulation = d3.forceSimulation()
					.nodes(nodes_data);
                              
var link_force =  d3.forceLink(links_data).strength(0.5);            
         
var charge_force = d3.forceManyBody()
    .strength(-100); 
    
var center_force = d3.forceCenter(width / 2, height / 2);  
                      
simulation
    .force("charge", charge_force)
    .force("center", center_force)
    .force("link",link_force)
 ;

        
//add tick instructions: 
//simulation.on("tick", tickActions );

//add encompassing group for the zoom 
var g = svg.append("g")
    .attr("class", "everything");

//draw lines for the links 
var link = g.append("g")
      .attr("class", "links")
    .selectAll("line")
    .data(links_data)
    .enter()
    .append("line")
      .attr("stroke-width", function(d){return d.type})
      .style("stroke", linkColour);        

//draw circles for the nodes 
var node = g.append("g")
        .attr("class", "nodes") 
        .selectAll("circle")
// before this was nodes_data
        .data(nodes_data)
        .enter()
        .append("circle")
        .attr("r", function(d){return d.type})
        .attr("fill", circleColour);
    
//    simulation
    simulation.nodes(nodes_data).on("tick",tickActions);
    

 
//add drag capabilities 
    
var drag_handler = d3.drag()
	.on("start", drag_start)
	.on("drag", drag_drag)
	.on("end", drag_end);	
	
drag_handler(node);


    
//add zoom capabilities 
var zoom_handler = d3.zoom()
    .on("zoom", zoom_actions);

zoom_handler(svg);     

/** Functions **/

//Function to choose what color circle we have
//Let's return blue for males and red for females
function circleColour(d){
		return "blue";
}

//Function to choose the line colour and thickness 
//If the link type is "A" return green 
//If the link type is "E" return red 
function linkColour(d){
		return "green";
}

//Drag functions 
//d is the node 
    
function drag_start(d) {
 if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

//make sure you can't drag the circle outside the box
function drag_drag(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function drag_end(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}
    
//Zoom functions
function zoom_actions(){
    g.attr("transform", d3.event.transform)
}

function tickActions() {
    //update circle positions each tick of the simulation 
       node
        .attr("cx", function(d) { return d.x})
        .attr("cy", function(d) { return d.y; });
        
    //update link positions 
    link
        .attr("x1", function(d,i) {
//        if (i===0){console.log(d)}
        return d.source.x})
        .attr("y1", function(d) { return d.source.y })
        .attr("x2", function(d) { return  d.target.x;})
        .attr("y2", function(d) { return  d.target.y});
} 
}
</script>
